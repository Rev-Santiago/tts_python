<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>⚡ HTTP TTS Stream</title>
    <style>
        body { font-family: system-ui, sans-serif; background: #111; color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; }
        .container { background: #222; padding: 2rem; border-radius: 12px; width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        h2 { margin-top: 0; color: #3b82f6; } /* Blue for HTTP */
        textarea { width: 100%; height: 80px; background: #333; color: #fff; border: 1px solid #444; border-radius: 6px; padding-right: 20px; padding: 10px; margin-bottom: 1rem; resize: none; font-family: inherit; }
        button { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; background: #3b82f6; color: #fff; font-size: 1rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { margin-top: 1rem; font-size: 0.9rem; color: #aaa; text-align: center; }
    </style>
</head>
<body>

<div class="container">
    <h2>⚡ HTTP TTS Streamer</h2>
    <textarea id="textInput">Explain black holes in one sentence.</textarea>
    <button id="playBtn">Generate & Stream (HTTP)</button>
    <div class="status" id="status">Ready</div>
</div>

<script>
    const playBtn = document.getElementById('playBtn');
    const statusDiv = document.getElementById('status');
    const textInput = document.getElementById('textInput');

    let audioCtx;
    let nextStartTime = 0;

    // Initialize Audio Context
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });
        } else if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    playBtn.onclick = async () => {
        const text = textInput.value.trim();
        if (!text) return;

        initAudio();
        playBtn.disabled = true;
        statusDiv.innerText = "Requesting...";
        
        // Reset timing
        nextStartTime = audioCtx.currentTime;

        try {
            // 1. Make the HTTP POST request
            const response = await fetch("http://localhost:8010/api/v1/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    text: text,
                    speaker_id: 0,
                    speed: 1.0
                })
            });

            if (!response.ok) throw new Error(`Server Error: ${response.status}`);

            // 2. Get the Readable Stream Reader
            const reader = response.body.getReader();
            statusDiv.innerText = "Streaming Audio...";

            // 3. Loop through chunks as they arrive
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                // 'value' is a Uint8Array. We need to schedule it.
                scheduleAudioChunk(value.buffer);
            }

            statusDiv.innerText = "Done";

        } catch (e) {
            statusDiv.innerText = "Error: " + e.message;
            console.error(e);
        } finally {
            playBtn.disabled = false;
        }
    };

    function scheduleAudioChunk(arrayBuffer) {
        // Convert Raw PCM (Int16) -> Float32 for Browser
        // Note: We need to handle byte offset carefully in case chunk is weirdly aligned
        const int16Data = new Int16Array(arrayBuffer);
        const float32Data = new Float32Array(int16Data.length);
        
        for (let i = 0; i < int16Data.length; i++) {
            float32Data[i] = int16Data[i] / 32768.0;
        }

        const buffer = audioCtx.createBuffer(1, float32Data.length, 22050);
        buffer.getChannelData(0).set(float32Data);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);

        // Gapless playback logic
        const scheduleTime = Math.max(audioCtx.currentTime, nextStartTime);
        source.start(scheduleTime);
        nextStartTime = scheduleTime + buffer.duration;
    }
</script>

</body>
</html>